{"version":3,"file":"static/js/15.0299b8bc.chunk.js","mappings":"0LACA,EAAwB,qBAAxB,EAAqD,qB,SC2CrD,IC1CA,EDGA,SAAcA,GASV,IARFC,EAAID,EAAJC,KACAC,EAAIF,EAAJE,KACAC,EAAKH,EAALG,MACAC,EAAKJ,EAALI,MACAC,EAAOL,EAAPK,QACAC,EAAQN,EAARM,SACAC,EAAYP,EAAZO,aACAC,EAAYR,EAAZQ,aAEA,OACEC,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAaC,SAAA,CAC1B,KACDC,EAAAA,EAAAA,KAAA,SACEL,aAAcA,EACdE,UAAWC,EACXV,KAAMA,EACNC,KAAMA,EACNE,MAAOA,EACPC,QAASA,EACTC,SAAUA,EACVQ,SAAUP,KAEZM,EAAAA,EAAAA,KAAA,SAAOE,QAASb,EAAKU,SAAET,MAG7B,C,8GE9BA,EAAuB,mB,SCqBvB,ICpBA,EDGA,SAAaH,GAA8B,IAA3BgB,EAAYhB,EAAZgB,aAAcJ,EAAQZ,EAARY,SAC5B,OACEC,EAAAA,EAAAA,KAAA,QAAMH,UAAWC,EAAaM,SAAUD,EAAaJ,SAClDA,GAGP,E,uCEXaM,EAAiB,SAAAC,GAAK,OAAIA,EAAMC,cAAcC,SAASC,KAAM,EAC7DC,EAAe,SAAAJ,GAAK,OAAIA,EAAMC,cAAcI,MAAO,EAEnDC,EAAgB,SAAAN,GAAK,OAAIA,EAAMC,cAAcC,SAASK,SAAU,EAChEC,EAAc,SAAAR,GAAK,OAAIA,EAAMC,cAAcC,SAASO,KAAM,E,0CCHvE,EAA0B,6BAA1B,EAA8D,0BAA9D,EAAsG,iCAAtG,EAAqJ,iCCCrJ,MCyBe,WACb,IAAAC,GAAoCC,EAAAA,EAAAA,UAAS,CAC3C5B,KAAM,GACN6B,OAAQ,KACRC,GAAAC,EAAAA,EAAAA,GAAAJ,EAAA,GAHKK,EAAUF,EAAA,GAAEG,EAAaH,EAAA,GAIhCI,GAAgCN,EAAAA,EAAAA,WAAS,GAAKO,GAAAJ,EAAAA,EAAAA,GAAAG,EAAA,GAAvCE,EAAQD,EAAA,GAAEE,EAAWF,EAAA,GAC5BG,GAAsCV,EAAAA,EAAAA,UAAS,IAAGW,GAAAR,EAAAA,EAAAA,GAAAO,EAAA,GAA3CE,EAAWD,EAAA,GAAEE,EAAcF,EAAA,GAC5BG,EC4MD,SAAqBC,EAAOC,GACjC,IAAAC,EAA4CC,EAAAA,SAAeH,GAAMI,GAAAhB,EAAAA,EAAAA,GAAAc,EAAA,GAA1DG,EAAcD,EAAA,GAAEE,EAAiBF,EAAA,GAYxC,OAVAD,EAAAA,WAAgB,WACd,IAAMI,EAAUC,YAAW,WACzBF,EAAkBN,EACpB,GAAGC,GAEH,OAAO,WACLQ,aAAaF,EACf,CACF,GAAG,CAACP,EAAOC,IAEJI,CACT,CD1N8BK,CAAYb,EAAa,KAE/Cc,GAAkBC,EAAAA,EAAAA,IAAYvC,GAI9BwC,GAAmBD,EAAAA,EAAAA,IAAYlC,GAG/BG,GAAY+B,EAAAA,EAAAA,IAAYhC,GACxBkC,GAAUF,EAAAA,EAAAA,IAAY9B,GAEtBiC,GAAWC,EAAAA,EAAAA,MAsBjB,SAAStD,EAAauD,GACpB,IAAAC,EAAwBD,EAAEE,OAAlB9D,EAAI6D,EAAJ7D,KAAM2C,EAAKkB,EAALlB,MAEO,IAAjBA,EAAMoB,SAGR9B,GAAa+B,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIhC,GAAU,IAAAiC,EAAAA,EAAAA,GAAA,GAAGjE,EAAO,MACvCqC,GAAY,IAGVM,EAAMoB,OAAS,IAGjB9B,GAAa+B,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIhC,GAAU,IAAAiC,EAAAA,EAAAA,GAAA,GAAGjE,EAAO2C,KACvCN,GAAY,IAGEiB,EAAgBY,MAAK,SAAAC,GAInC,OADAC,QAAQC,IAAIF,EAAQnE,KAAKsE,gBAAkB3B,EAAM2B,eAC1CH,EAAQnE,OAAS2C,CAC1B,MAGEyB,QAAQC,IAAI,UAEZE,MAAM,GAADC,OAAI7B,EAAK,4BACdV,GAAa+B,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIhC,GAAU,IAAAiC,EAAAA,EAAAA,GAAA,GAAGjE,EAAO,MACvCqC,GAAY,GAEhB,EAnDAoC,EAAAA,EAAAA,YAAU,WACRf,GAASgB,EAAAA,EAAAA,MACX,GAAG,CAAChB,KAEJe,EAAAA,EAAAA,YAAU,WACRf,GAASiB,EAAAA,EAAAA,GAAcjC,GACzB,GAAG,CAACgB,EAAUhB,IAoEd,IAAIkC,EAAoB,GAkBxB,OAfqC,IAAnCtB,EAAgBuB,SAAS,YACLC,IAApBxB,IAIAsB,EAAoBtB,EAAgBhC,QAAO,SAAA6C,GAMzC,OAHgBA,EAAQnE,KACrBsE,cACAO,SAASrB,EAAiBc,cAE/B,MAIA/D,EAAAA,EAAAA,MAAA,WAASC,UAAWC,EAAeC,SAAA,EACjCC,EAAAA,EAAAA,KAAA,MAAAD,SAAI,eACJH,EAAAA,EAAAA,MAACwE,EAAI,CAACjE,aAvFV,SAAsBkE,GACpBA,EAAGC,iBACH,IAAMC,EAAOF,EAAGlB,OAKhBJ,GAASyB,EAAAA,EAAAA,IAAWnD,IAEpBkD,EAAKE,OACP,EA6EqC1E,SAAA,EAC/BC,EAAAA,EAAAA,KAAC0E,EAAAA,EAAK,CACJtF,KAAK,OACLC,KAAK,OACLC,MAAM,OACNE,QAAQ,2CACRD,MAAM,yIACNE,UAAU,EACVC,aAAcA,KAGhBM,EAAAA,EAAAA,KAAC0E,EAAAA,EAAK,CACJtF,KAAK,MACLC,KAAK,SACLC,MAAM,SACNE,QAAQ,yFACRD,MAAM,+FACNE,UAAU,EACVC,aAAcA,KAGhBM,EAAAA,EAAAA,KAAC2E,EAAAA,EAAM,CAACvF,KAAK,SAASqC,SAAUA,EAAS1B,SAAC,oBAI5CC,EAAAA,EAAAA,KAAA,UAAY,KACZA,EAAAA,EAAAA,KAAC0E,EAAAA,EAAK,CACJtF,KAAK,OACLC,KAAK,cACLC,MAAM,wBACNC,MAAM,YACNE,UAAU,EACVC,aA1EN,SAA4BuD,GAC1B,IAAQjB,EAAUiB,EAAEE,OAAZnB,MAEJA,EAAMoB,OAAS,GAGjBtB,EAAeE,GAGI,IAAjBA,EAAMoB,QAGRtB,EAAe,GAEnB,KA8DIlC,EAAAA,EAAAA,MAAA,OAAAG,SAAA,EACEC,EAAAA,EAAAA,KAAA,MAAI4E,MAAO,CAAEC,OAAQ,eAAgB9E,SAAC,cACtCH,EAAAA,EAAAA,MAAA,KAAGgF,MAAO,CAAEE,SAAU,OAAQD,OAAQ,KAAM9E,SAAA,CAAC,mBAC1B4C,EAAgBS,WAEnCxD,EAAAA,EAAAA,MAAA,KAAGgF,MAAO,CAAEE,SAAU,OAAQD,OAAQ,KAAM9E,SAAA,CAAC,mBAC1BkE,EAAkBb,aAGtCvC,IAAab,EAAAA,EAAAA,KAAC+E,EAAAA,EAAO,IACrBjC,IAAW9C,EAAAA,EAAAA,KAACgF,EAAAA,EAAK,CAACC,QAASnC,KACQ,IAAnCH,EAAgBuB,SAAS,QACxBlE,EAAAA,EAAAA,KAAA,MAAIH,UAAWC,EAAmBC,SAC/BkE,EAAkBiB,KAAI,SAAA1B,GACrB,OACE5D,EAAAA,EAAAA,MAAA,MAAIC,UAAWC,EAAmBC,SAAA,EAChCC,EAAAA,EAAAA,KAAA,QAAMH,UAAWC,KACjBE,EAAAA,EAAAA,KAAA,QAAAD,UACEH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAIyD,EAAQnE,KAAK,WAEnBW,EAAAA,EAAAA,KAAA,QAAAD,UACEC,EAAAA,EAAAA,KAAA,KAAAD,SAAIyD,EAAQtC,YAEdlB,EAAAA,EAAAA,KAAC2E,EAAAA,EAAM,CACLQ,SAAS,EACT/F,KAAK,SACLqC,UAAU,EACV2D,YAAa,WAvF7B,IAAsBC,IAwFS7B,EAAQ6B,GAtFrCtC,GAASuC,EAAAA,EAAAA,IAAcD,GAuFT,EAAEtF,SACH,aAfqCyD,EAAQ6B,GAoBpD,QAKV,EEtNe,SAASE,IACtB,OAAOvF,EAAAA,EAAAA,KAACwF,EAAW,GACrB,C","sources":["webpack://goit-react-hw-08-phonebooks/./src/components/common/input/input.module.css?f862","components/common/input/Input.jsx","components/common/input/index.js","webpack://goit-react-hw-08-phonebooks/./src/components/form/Form.module.css?1d3b","components/form/Form.jsx","components/form/index.js","redux/contacts/selectors.js","webpack://goit-react-hw-08-phonebooks/./src/components/ContactBook/ContactBook.module.css?f30d","components/ContactBook/index.js","components/ContactBook/ContactBook.jsx","../node_modules/@uidotdev/usehooks/index.js","pages/ContactsPage/ContactsPage.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"field\":\"input_field__KOos0\",\"input\":\"input_input__Yr94O\"};","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport styles from './input.module.css';\n\nfunction Input({\n  type,\n  name,\n  label,\n  title,\n  pattern,\n  required,\n  handleChange,\n  autoComplete,\n}) {\n  return (\n    <div className={styles.field}>\n      {' '}\n      <input\n        autoComplete={autoComplete}\n        className={styles.input}\n        type={type}\n        name={name}\n        title={title}\n        pattern={pattern}\n        required={required}\n        onChange={handleChange}\n      ></input>\n      <label htmlFor={name}>{label}</label>\n    </div>\n  );\n}\n\nInput.propTypes = {\n  name: PropTypes.string,\n  type: PropTypes.string,\n  label: PropTypes.string,\n  title: PropTypes.string,\n  required: PropTypes.bool,\n  handleChange: PropTypes.func,\n  pattern: PropTypes.string,\n  autoComplete: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n};\n\nexport default Input;\n","import Input from './Input';\n\nexport default Input;\n","// extracted by mini-css-extract-plugin\nexport default {\"form\":\"Form_form__gjyi8\"};","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport styles from './Form.module.css';\n\nfunction Form({ handleSubmit, children }) {\n  return (\n    <form className={styles.form} onSubmit={handleSubmit}>\n      {children}\n    </form>\n  );\n}\n\nForm.propTypes = {\n  handleSubmit: PropTypes.func,\n  children: PropTypes.oneOfType([\n    PropTypes.element,\n    PropTypes.array,\n    PropTypes.string,\n  ]),\n};\n\nexport default Form;\n","import Form from './Form';\n\nexport default Form;\n","export const selectContacts = state => state.contactsSlice.contacts.items;\nexport const selectFilter = state => state.contactsSlice.filter;\n\nexport const selectLoading = state => state.contactsSlice.contacts.isLoading;\nexport const selectError = state => state.contactsSlice.contacts.error;\n","// extracted by mini-css-extract-plugin\nexport default {\"section\":\"ContactBook_section__kbJnm\",\"span\":\"ContactBook_span__8GjeR\",\"contactList\":\"ContactBook_contactList__E3hCk\",\"contactItem\":\"ContactBook_contactItem__dXnIi\"};","import ContactBook from './ContactBook';\n\nexport default ContactBook;\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\n\nimport Form from 'components/form';\nimport Input from 'components/common/input';\nimport Button from 'components/common/button';\n\nimport { useDispatch, useSelector } from 'react-redux';\nimport {\n  addContact,\n  deleteContact,\n  fetchContacts,\n} from '../../redux/operations';\nimport {\n  selectContacts,\n  selectFilter,\n  selectLoading,\n  selectError,\n} from '../../redux/contacts/selectors';\nimport { useDebounce } from '@uidotdev/usehooks';\nimport { filterContact } from '../../redux/contacts/contactsSlice';\n\nimport Loading from 'components/common/Loading';\nimport Alert from 'components/common/Alert';\n\nimport styles from './ContactBook.module.css';\n\nexport default function ContactBook() {\n  const [newContact, setNewContact] = useState({\n    name: '',\n    number: '',\n  });\n  const [disabled, setDisabled] = useState(true);\n  const [searchTherm, setSearchTherm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTherm, 1000);\n\n  const initialContacts = useSelector(selectContacts);\n  // console.log(initialContacts);\n  // console.log(initialContacts.includes(null) === false);\n\n  const filterSliceStore = useSelector(selectFilter);\n  // console.log(filter);\n\n  const isLoading = useSelector(selectLoading);\n  const isError = useSelector(selectError);\n\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    dispatch(fetchContacts());\n  }, [dispatch]);\n\n  useEffect(() => {\n    dispatch(filterContact(debouncedSearchTerm));\n  }, [dispatch, debouncedSearchTerm]);\n\n  function handleSubmit(ev) {\n    ev.preventDefault();\n    const form = ev.target;\n\n    // console.log(newContact.name);\n    // console.log(newContact.number);\n\n    dispatch(addContact(newContact));\n\n    form.reset();\n  }\n\n  function handleChange(e) {\n    const { name, value } = e.target;\n\n    if (value.length === 0) {\n      // console.log('hey');\n\n      setNewContact({ ...newContact, [name]: '' });\n      setDisabled(true);\n    }\n\n    if (value.length > 0) {\n      // console.log('hey');\n\n      setNewContact({ ...newContact, [name]: value });\n      setDisabled(false);\n    }\n\n    const isExist = initialContacts.find(contact => {\n      // console.log(contact.name);\n\n      console.log(contact.name.toLowerCase() === value.toLowerCase());\n      return contact.name === value;\n    });\n\n    if (isExist) {\n      console.log('trueee');\n\n      alert(`${value} este deja in contacte.`);\n      setNewContact({ ...newContact, [name]: '' });\n      setDisabled(true);\n    }\n  }\n\n  function handleSearchChange(e) {\n    const { value } = e.target;\n\n    if (value.length > 0) {\n      // console.log('hey');\n\n      setSearchTherm(value);\n    }\n\n    if (value.length === 0) {\n      // console.log('hey');\n\n      setSearchTherm('');\n    }\n  }\n\n  function handleRemove(id) {\n    // console.log(id);\n    dispatch(deleteContact(id));\n  }\n\n  let getContactsByName = [];\n\n  if (\n    initialContacts.includes(null) === false ||\n    initialContacts !== undefined\n  ) {\n    // console.log(initialContacts);\n\n    getContactsByName = initialContacts.filter(contact => {\n      // console.log(contact);\n\n      const isFound = contact.name\n        .toLowerCase()\n        .includes(filterSliceStore.toLowerCase());\n      return isFound;\n    });\n  }\n\n  return (\n    <section className={styles.section}>\n      <h1>Phonebook</h1>\n      <Form handleSubmit={handleSubmit}>\n        <Input\n          type=\"text\"\n          name=\"name\"\n          label=\"Name\"\n          pattern=\"^[a-zA-Z]+(([' -][a-zA-Z ])?[a-zA-Z]*)*$\"\n          title=\"Name may contain only letters, apostrophe, dash and spaces. For example Adrian, Jacob Mercer, Charles de Batz de Castelmore d'Artagnan\"\n          required={true}\n          handleChange={handleChange}\n        />\n\n        <Input\n          type=\"tel\"\n          name=\"number\"\n          label=\"Number\"\n          pattern=\"/(?:([+]d{1,4})[-.s]?)?(?:[(](d{1,3})[)][-.s]?)?(d{1,4})[-.s]?(d{1,4})[-.s]?(d{1,9})/g\"\n          title=\"Phone number must be digits and can contain spaces, dashes, parentheses and can start with +\"\n          required={true}\n          handleChange={handleChange}\n        />\n\n        <Button type=\"submit\" disabled={disabled}>\n          Add contact\n        </Button>\n      </Form>\n      <div></div>{' '}\n      <Input\n        type=\"text\"\n        name=\"searchTherm\"\n        label=\"Find contacts by name\"\n        title=\"Type name\"\n        required={false}\n        handleChange={handleSearchChange}\n      />\n      <div>\n        <h2 style={{ margin: '10px 0 20px' }}>Contacts</h2>\n        <p style={{ fontSize: '24px', margin: '0' }}>\n          Total Contacts: {initialContacts.length}\n        </p>\n        <p style={{ fontSize: '24px', margin: '0' }}>\n          Contacts found: {getContactsByName.length}\n        </p>\n      </div>\n      {isLoading && <Loading />}\n      {isError && <Alert message={isError} />}\n      {initialContacts.includes(null) === false && (\n        <ul className={styles.contactList}>\n          {getContactsByName.map(contact => {\n            return (\n              <li className={styles.contactItem} key={contact.id}>\n                <span className={styles.span}></span>\n                <span>\n                  <b>{contact.name} :</b>\n                </span>\n                <span>\n                  <b>{contact.number}</b>\n                </span>\n                <Button\n                  variant={true}\n                  type=\"button\"\n                  disabled={false}\n                  handleClick={() => {\n                    handleRemove(contact.id);\n                  }}\n                >\n                  Delete\n                </Button>\n              </li>\n            );\n          })}\n        </ul>\n      )}\n    </section>\n  );\n}\n\nContactBook.propTypes = {\n  disabled: PropTypes.bool,\n  searchTherm: PropTypes.string,\n  initialContacts: PropTypes.array,\n};\n","import * as React from \"react\";\n\nfunction isShallowEqual(object1, object2) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let key of keys1) {\n    if (object1[key] !== object2[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTouchEvent({ nativeEvent }) {\n  return window.TouchEvent\n    ? nativeEvent instanceof TouchEvent\n    : \"touches\" in nativeEvent;\n}\n\nfunction isMouseEvent(event) {\n  return event.nativeEvent instanceof MouseEvent;\n}\n\nfunction throttle(cb, ms) {\n  let lastTime = 0;\n  return () => {\n    const now = Date.now();\n    if (now - lastTime >= ms) {\n      cb();\n      lastTime = now;\n    }\n  };\n}\n\nfunction isPlainObject(value) {\n  return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n\nfunction dispatchStorageEvent(key, newValue) {\n  window.dispatchEvent(new StorageEvent(\"storage\", { key, newValue }));\n}\n\nexport function useBattery() {\n  const [state, setState] = React.useState({\n    supported: true,\n    loading: true,\n    level: null,\n    charging: null,\n    chargingTime: null,\n    dischargingTime: null,\n  });\n\n  React.useEffect(() => {\n    if (!navigator.getBattery) {\n      setState((s) => ({\n        ...s,\n        supported: false,\n        loading: false,\n      }));\n      return;\n    }\n\n    let battery = null;\n\n    const handleChange = () => {\n      setState({\n        supported: true,\n        loading: false,\n        level: battery.level,\n        charging: battery.charging,\n        chargingTime: battery.chargingTime,\n        dischargingTime: battery.dischargingTime,\n      });\n    };\n\n    navigator.getBattery().then((b) => {\n      battery = b;\n      handleChange();\n\n      b.addEventListener(\"levelchange\", handleChange);\n      b.addEventListener(\"chargingchange\", handleChange);\n      b.addEventListener(\"chargingtimechange\", handleChange);\n      b.addEventListener(\"dischargingtimechange\", handleChange);\n    });\n\n    return () => {\n      if (battery) {\n        battery.removeEventListener(\"levelchange\", handleChange);\n        battery.removeEventListener(\"chargingchange\", handleChange);\n        battery.removeEventListener(\"chargingtimechange\", handleChange);\n        battery.removeEventListener(\"dischargingtimechange\", handleChange);\n      }\n    };\n  }, []);\n\n  return state;\n}\n\nexport function useClickAway(cb) {\n  const ref = React.useRef(null);\n  const refCb = React.useRef(cb);\n\n  React.useLayoutEffect(() => {\n    refCb.current = cb;\n  });\n\n  React.useEffect(() => {\n    const handler = (e) => {\n      const element = ref.current;\n      if (element && !element.contains(e.target)) {\n        refCb.current(e);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handler);\n    document.addEventListener(\"touchstart\", handler);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handler);\n      document.removeEventListener(\"touchstart\", handler);\n    };\n  }, []);\n\n  return ref;\n}\n\nfunction oldSchoolCopy(text) {\n  const tempTextArea = document.createElement(\"textarea\");\n  tempTextArea.value = text;\n  document.body.appendChild(tempTextArea);\n  tempTextArea.select();\n  document.execCommand(\"copy\");\n  document.body.removeChild(tempTextArea);\n}\n\nexport function useCopyToClipboard() {\n  const [state, setState] = React.useState(null);\n\n  const copyToClipboard = React.useCallback((value) => {\n    const handleCopy = async () => {\n      try {\n        if (navigator?.clipboard?.writeText) {\n          await navigator.clipboard.writeText(value);\n          setState(value);\n        } else {\n          throw new Error(\"writeText not supported\");\n        }\n      } catch (e) {\n        oldSchoolCopy(value);\n        setState(value);\n      }\n    };\n\n    handleCopy();\n  }, []);\n\n  return [state, copyToClipboard];\n}\n\nexport function useCounter(startingValue = 0, options = {}) {\n  const { min, max } = options;\n\n  if (typeof min === \"number\" && startingValue < min) {\n    throw new Error(\n      `Your starting value of ${startingValue} is less than your min of ${min}.`\n    );\n  }\n\n  if (typeof max === \"number\" && startingValue > max) {\n    throw new Error(\n      `Your starting value of ${startingValue} is greater than your max of ${max}.`\n    );\n  }\n\n  const [count, setCount] = React.useState(startingValue);\n\n  const increment = React.useCallback(() => {\n    setCount((c) => {\n      const nextCount = c + 1;\n\n      if (typeof max === \"number\" && nextCount > max) {\n        return c;\n      }\n\n      return nextCount;\n    });\n  }, [max]);\n\n  const decrement = React.useCallback(() => {\n    setCount((c) => {\n      const nextCount = c - 1;\n\n      if (typeof min === \"number\" && nextCount < min) {\n        return c;\n      }\n\n      return nextCount;\n    });\n  }, [min]);\n\n  const set = React.useCallback(\n    (nextCount) => {\n      setCount((c) => {\n        if (typeof max === \"number\" && nextCount > max) {\n          return c;\n        }\n\n        if (typeof min === \"number\" && nextCount < min) {\n          return c;\n        }\n\n        return nextCount;\n      });\n    },\n    [max, min]\n  );\n\n  const reset = React.useCallback(() => {\n    setCount(startingValue);\n  }, [startingValue]);\n\n  return [\n    count,\n    {\n      increment,\n      decrement,\n      set,\n      reset,\n    },\n  ];\n}\n\nexport function useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = React.useState(value);\n\n  React.useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nexport function useDefault(initialValue, defaultValue) {\n  const [state, setState] = React.useState(initialValue);\n\n  if (typeof state === \"undefined\" || state === null) {\n    return [defaultValue, setState];\n  }\n\n  return [state, setState];\n}\n\nexport function useDocumentTitle(title) {\n  React.useEffect(() => {\n    document.title = title;\n  }, [title]);\n}\n\nexport function useFavicon(url) {\n  React.useEffect(() => {\n    let link = document.querySelector(`link[rel~=\"icon\"]`);\n\n    if (!link) {\n      link = document.createElement(\"link\");\n      link.type = \"image/x-icon\";\n      link.rel = \"icon\";\n      link.href = url;\n      document.head.appendChild(link);\n    } else {\n      link.href = url;\n    }\n  }, [url]);\n}\n\nexport function useGeolocation(options = {}) {\n  const [state, setState] = React.useState({\n    loading: true,\n    accuracy: null,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    latitude: null,\n    longitude: null,\n    speed: null,\n    timestamp: null,\n    error: null,\n  });\n\n  const optionsRef = React.useRef(options);\n\n  React.useEffect(() => {\n    const onEvent = ({ coords, timestamp }) => {\n      setState({\n        loading: false,\n        timestamp,\n        latitude: coords.latitude,\n        longitude: coords.longitude,\n        altitude: coords.altitude,\n        accuracy: coords.accuracy,\n        altitudeAccuracy: coords.altitudeAccuracy,\n        heading: coords.heading,\n        speed: coords.speed,\n      });\n    };\n\n    const onEventError = (error) => {\n      setState((s) => ({\n        ...s,\n        loading: false,\n        error,\n      }));\n    };\n\n    navigator.geolocation.getCurrentPosition(\n      onEvent,\n      onEventError,\n      optionsRef.current\n    );\n\n    const watchId = navigator.geolocation.watchPosition(\n      onEvent,\n      onEventError,\n      optionsRef.current\n    );\n\n    return () => {\n      navigator.geolocation.clearWatch(watchId);\n    };\n  }, []);\n\n  return state;\n}\n\nconst initialUseHistoryStateState = {\n  past: [],\n  present: null,\n  future: [],\n};\n\nconst useHistoryStateReducer = (state, action) => {\n  const { past, present, future } = state;\n\n  if (action.type === \"UNDO\") {\n    return {\n      past: past.slice(0, past.length - 1),\n      present: past[past.length - 1],\n      future: [present, ...future],\n    };\n  } else if (action.type === \"REDO\") {\n    return {\n      past: [...past, present],\n      present: future[0],\n      future: future.slice(1),\n    };\n  } else if (action.type === \"SET\") {\n    const { newPresent } = action;\n\n    if (action.newPresent === present) {\n      return state;\n    }\n\n    return {\n      past: [...past, present],\n      present: newPresent,\n      future: [],\n    };\n  } else if (action.type === \"CLEAR\") {\n    return {\n      ...initialUseHistoryStateState,\n      present: action.initialPresent,\n    };\n  } else {\n    throw new Error(\"Unsupported action type\");\n  }\n};\n\nexport function useHistoryState(initialPresent = {}) {\n  const initialPresentRef = React.useRef(initialPresent);\n\n  const [state, dispatch] = React.useReducer(useHistoryStateReducer, {\n    ...initialUseHistoryStateState,\n    present: initialPresentRef.current,\n  });\n\n  const canUndo = state.past.length !== 0;\n  const canRedo = state.future.length !== 0;\n\n  const undo = React.useCallback(() => {\n    if (canUndo) {\n      dispatch({ type: \"UNDO\" });\n    }\n  }, [canUndo]);\n\n  const redo = React.useCallback(() => {\n    if (canRedo) {\n      dispatch({ type: \"REDO\" });\n    }\n  }, [canRedo]);\n\n  const set = React.useCallback(\n    (newPresent) => dispatch({ type: \"SET\", newPresent }),\n    []\n  );\n\n  const clear = React.useCallback(\n    () =>\n      dispatch({ type: \"CLEAR\", initialPresent: initialPresentRef.current }),\n    []\n  );\n\n  return { state: state.present, set, undo, redo, clear, canUndo, canRedo };\n}\n\nexport function useHover() {\n  const [hovering, setHovering] = React.useState(false);\n  const previousNode = React.useRef(null);\n\n  const handleMouseEnter = React.useCallback(() => {\n    setHovering(true);\n  }, []);\n\n  const handleMouseLeave = React.useCallback(() => {\n    setHovering(false);\n  }, []);\n\n  const customRef = React.useCallback(\n    (node) => {\n      if (previousNode.current?.nodeType === Node.ELEMENT_NODE) {\n        previousNode.current.removeEventListener(\n          \"mouseenter\",\n          handleMouseEnter\n        );\n        previousNode.current.removeEventListener(\n          \"mouseleave\",\n          handleMouseLeave\n        );\n      }\n\n      if (node?.nodeType === Node.ELEMENT_NODE) {\n        node.addEventListener(\"mouseenter\", handleMouseEnter);\n        node.addEventListener(\"mouseleave\", handleMouseLeave);\n      }\n\n      previousNode.current = node;\n    },\n    [handleMouseEnter, handleMouseLeave]\n  );\n\n  return [customRef, hovering];\n}\n\nexport function useIdle(ms = 1000 * 60) {\n  const [idle, setIdle] = React.useState(false);\n\n  React.useEffect(() => {\n    let timeoutId;\n\n    const handleTimeout = () => {\n      setIdle(true);\n    };\n\n    const handleEvent = throttle((e) => {\n      setIdle(false);\n\n      window.clearTimeout(timeoutId);\n      timeoutId = window.setTimeout(handleTimeout, ms);\n    }, 500);\n\n    const handleVisibilityChange = () => {\n      if (!document.hidden) {\n        handleEvent();\n      }\n    };\n\n    timeoutId = window.setTimeout(handleTimeout, ms);\n\n    window.addEventListener(\"mousemove\", handleEvent);\n    window.addEventListener(\"mousedown\", handleEvent);\n    window.addEventListener(\"resize\", handleEvent);\n    window.addEventListener(\"keydown\", handleEvent);\n    window.addEventListener(\"touchstart\", handleEvent);\n    window.addEventListener(\"wheel\", handleEvent);\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleEvent);\n      window.removeEventListener(\"mousedown\", handleEvent);\n      window.removeEventListener(\"resize\", handleEvent);\n      window.removeEventListener(\"keydown\", handleEvent);\n      window.removeEventListener(\"touchstart\", handleEvent);\n      window.removeEventListener(\"wheel\", handleEvent);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.clearTimeout(timeoutId);\n    };\n  }, [ms]);\n\n  return idle;\n}\n\nexport function useIntersectionObserver(options = {}) {\n  const { threshold = 1, root = null, rootMargin = \"0px\" } = options;\n  const [entry, setEntry] = React.useState(null);\n\n  const previousObserver = React.useRef(null);\n\n  const customRef = React.useCallback(\n    (node) => {\n      if (previousObserver.current) {\n        previousObserver.current.disconnect();\n        previousObserver.current = null;\n      }\n\n      if (node?.nodeType === Node.ELEMENT_NODE) {\n        const observer = new IntersectionObserver(\n          ([entry]) => {\n            setEntry(entry);\n          },\n          { threshold, root, rootMargin }\n        );\n\n        observer.observe(node);\n        previousObserver.current = observer;\n      }\n    },\n    [threshold, root, rootMargin]\n  );\n\n  return [customRef, entry];\n}\n\nexport function useIsClient() {\n  const [isClient, setIsClient] = React.useState(false);\n\n  React.useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return isClient;\n}\n\nexport function useIsFirstRender() {\n  const renderRef = React.useRef(true);\n\n  if (renderRef.current === true) {\n    renderRef.current = false;\n    return true;\n  }\n\n  return renderRef.current;\n}\n\nexport function useList(defaultList = []) {\n  const [list, setList] = React.useState(defaultList);\n\n  const set = React.useCallback((l) => {\n    setList(l);\n  }, []);\n\n  const push = React.useCallback((element) => {\n    setList((l) => [...l, element]);\n  }, []);\n\n  const removeAt = React.useCallback((index) => {\n    setList((l) => [...l.slice(0, index), ...l.slice(index + 1)]);\n  }, []);\n\n  const insertAt = React.useCallback((index, element) => {\n    setList((l) => [...l.slice(0, index), element, ...l.slice(index)]);\n  }, []);\n\n  const updateAt = React.useCallback((index, element) => {\n    setList((l) => l.map((e, i) => (i === index ? element : e)));\n  }, []);\n\n  const clear = React.useCallback(() => setList([]), []);\n\n  return [list, { set, push, removeAt, insertAt, updateAt, clear }];\n}\n\nconst setLocalStorageItem = (key, value) => {\n  const stringifiedValue = JSON.stringify(value);\n  window.localStorage.setItem(key, stringifiedValue);\n  dispatchStorageEvent(key, stringifiedValue);\n};\n\nconst removeLocalStorageItem = (key) => {\n  window.localStorage.removeItem(key);\n  dispatchStorageEvent(key, null);\n};\n\nconst getLocalStorageItem = (key) => {\n  return window.localStorage.getItem(key);\n};\n\nconst useLocalStorageSubscribe = (callback) => {\n  window.addEventListener(\"storage\", callback);\n  return () => window.removeEventListener(\"storage\", callback);\n};\n\nconst getLocalStorageServerSnapshot = () => {\n  throw Error(\"useLocalStorage is a client-only hook\");\n};\n\nexport function useLocalStorage(key, initialValue) {\n  const getSnapshot = () => getLocalStorageItem(key);\n\n  const store = React.useSyncExternalStore(\n    useLocalStorageSubscribe,\n    getSnapshot,\n    getLocalStorageServerSnapshot\n  );\n\n  const setState = React.useCallback(\n    (v) => {\n      try {\n        const nextState = typeof v === \"function\" ? v(JSON.parse(store)) : v;\n\n        if (nextState === undefined || nextState === null) {\n          removeLocalStorageItem(key);\n        } else {\n          setLocalStorageItem(key, nextState);\n        }\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n    [key, store]\n  );\n\n  React.useEffect(() => {\n    if (\n      getLocalStorageItem(key) === null &&\n      typeof initialValue !== \"undefined\"\n    ) {\n      setLocalStorageItem(key, initialValue);\n    }\n  }, [key, initialValue]);\n\n  return [store ? JSON.parse(store) : initialValue, setState];\n}\n\nexport function useLockBodyScroll() {\n  React.useLayoutEffect(() => {\n    const originalStyle = window.getComputedStyle(document.body).overflow;\n    document.body.style.overflow = \"hidden\";\n    return () => {\n      document.body.style.overflow = originalStyle;\n    };\n  }, []);\n}\n\nexport function useLongPress(callback, options = {}) {\n  const { threshold = 400, onStart, onFinish, onCancel } = options;\n  const isLongPressActive = React.useRef(false);\n  const isPressed = React.useRef(false);\n  const timerId = React.useRef();\n\n  return React.useMemo(() => {\n    if (typeof callback !== \"function\") {\n      return {};\n    }\n\n    const start = (event) => {\n      if (!isMouseEvent(event) && !isTouchEvent(event)) return;\n\n      if (onStart) {\n        onStart(event);\n      }\n\n      isPressed.current = true;\n      timerId.current = setTimeout(() => {\n        callback(event);\n        isLongPressActive.current = true;\n      }, threshold);\n    };\n\n    const cancel = (event) => {\n      if (!isMouseEvent(event) && !isTouchEvent(event)) return;\n\n      if (isLongPressActive.current) {\n        if (onFinish) {\n          onFinish(event);\n        }\n      } else if (isPressed.current) {\n        if (onCancel) {\n          onCancel(event);\n        }\n      }\n\n      isLongPressActive.current = false;\n      isPressed.current = false;\n\n      if (timerId.current) {\n        window.clearTimeout(timerId.current);\n      }\n    };\n\n    const mouseHandlers = {\n      onMouseDown: start,\n      onMouseUp: cancel,\n      onMouseLeave: cancel,\n    };\n\n    const touchHandlers = {\n      onTouchStart: start,\n      onTouchEnd: cancel,\n    };\n\n    return {\n      ...mouseHandlers,\n      ...touchHandlers,\n    };\n  }, [callback, threshold, onCancel, onFinish, onStart]);\n}\n\nexport function useMap(initialState) {\n  const mapRef = React.useRef(new Map(initialState));\n  const [, reRender] = React.useReducer((x) => x + 1, 0);\n\n  mapRef.current.set = (...args) => {\n    Map.prototype.set.apply(mapRef.current, args);\n    reRender();\n    return mapRef.current;\n  };\n\n  mapRef.current.clear = (...args) => {\n    Map.prototype.clear.apply(mapRef.current, args);\n    reRender();\n  };\n\n  mapRef.current.delete = (...args) => {\n    const res = Map.prototype.delete.apply(mapRef.current, args);\n    reRender();\n\n    return res;\n  };\n\n  return mapRef.current;\n}\n\nexport function useMeasure() {\n  const [dimensions, setDimensions] = React.useState({\n    width: null,\n    height: null,\n  });\n\n  const previousObserver = React.useRef(null);\n\n  const customRef = React.useCallback((node) => {\n    if (previousObserver.current) {\n      previousObserver.current.disconnect();\n      previousObserver.current = null;\n    }\n\n    if (node?.nodeType === Node.ELEMENT_NODE) {\n      const observer = new ResizeObserver(([entry]) => {\n        if (entry && entry.borderBoxSize) {\n          const { inlineSize: width, blockSize: height } =\n            entry.borderBoxSize[0];\n\n          setDimensions({ width, height });\n        }\n      });\n\n      observer.observe(node);\n      previousObserver.current = observer;\n    }\n  }, []);\n\n  return [customRef, dimensions];\n}\n\nexport function useMediaQuery(query) {\n  const subscribe = React.useCallback(\n    (callback) => {\n      const matchMedia = window.matchMedia(query);\n\n      matchMedia.addEventListener(\"change\", callback);\n      return () => {\n        matchMedia.removeEventListener(\"change\", callback);\n      };\n    },\n    [query]\n  );\n\n  const getSnapshot = () => {\n    return window.matchMedia(query).matches;\n  };\n\n  const getServerSnapshot = () => {\n    throw Error(\"useMediaQuery is a client-only hook\");\n  };\n\n  return React.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\nexport function useMouse() {\n  const [state, setState] = React.useState({\n    x: 0,\n    y: 0,\n    elementX: 0,\n    elementY: 0,\n    elementPositionX: 0,\n    elementPositionY: 0,\n  });\n\n  const ref = React.useRef(null);\n\n  React.useLayoutEffect(() => {\n    const handleMouseMove = (event) => {\n      let newState = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current?.nodeType === Node.ELEMENT_NODE) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => {\n        return {\n          ...s,\n          ...newState,\n        };\n      });\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n\nconst getConnection = () => {\n  return (\n    navigator?.connection ||\n    navigator?.mozConnection ||\n    navigator?.webkitConnection\n  );\n};\n\nconst useNetworkStateSubscribe = (callback) => {\n  window.addEventListener(\"online\", callback, { passive: true });\n  window.addEventListener(\"offline\", callback, { passive: true });\n\n  const connection = getConnection();\n\n  if (connection) {\n    connection.addEventListener(\"change\", callback, { passive: true });\n  }\n\n  return () => {\n    window.removeEventListener(\"online\", callback);\n    window.removeEventListener(\"offline\", callback);\n\n    if (connection) {\n      connection.removeEventListener(\"change\", callback);\n    }\n  };\n};\n\nconst getNetworkStateServerSnapshot = () => {\n  throw Error(\"useNetworkState is a client-only hook\");\n};\n\nexport function useNetworkState() {\n  const cache = React.useRef({});\n\n  const getSnapshot = () => {\n    const online = navigator.onLine;\n    const connection = getConnection();\n\n    const nextState = {\n      online,\n      downlink: connection?.downlink,\n      downlinkMax: connection?.downlinkMax,\n      effectiveType: connection?.effectiveType,\n      rtt: connection?.rtt,\n      saveData: connection?.saveData,\n      type: connection?.type,\n    };\n\n    if (isShallowEqual(cache.current, nextState)) {\n      return cache.current;\n    } else {\n      cache.current = nextState;\n      return nextState;\n    }\n  };\n\n  return React.useSyncExternalStore(\n    useNetworkStateSubscribe,\n    getSnapshot,\n    getNetworkStateServerSnapshot\n  );\n}\n\nexport function useObjectState(initialValue) {\n  const [state, setState] = React.useState(initialValue);\n\n  const handleUpdate = React.useCallback((arg) => {\n    if (typeof arg === \"function\") {\n      setState((s) => {\n        const newState = arg(s);\n\n        if (isPlainObject(newState)) {\n          return {\n            ...s,\n            ...newState,\n          };\n        }\n      });\n    }\n\n    if (isPlainObject(arg)) {\n      setState((s) => ({\n        ...s,\n        ...arg,\n      }));\n    }\n  }, []);\n\n  return [state, handleUpdate];\n}\n\nexport function useOrientation() {\n  const [orientation, setOrientation] = React.useState({\n    angle: 0,\n    type: \"landscape-primary\",\n  });\n\n  React.useLayoutEffect(() => {\n    const handleChange = () => {\n      const { angle, type } = window.screen.orientation;\n      setOrientation({\n        angle,\n        type,\n      });\n    };\n\n    const handle_orientationchange = () => {\n      setOrientation({\n        type: \"UNKNOWN\",\n        angle: window.orientation,\n      });\n    };\n\n    if (window.screen?.orientation) {\n      handleChange();\n      window.screen.orientation.addEventListener(\"change\", handleChange);\n    } else {\n      handle_orientationchange();\n      window.addEventListener(\"orientationchange\", handle_orientationchange);\n    }\n\n    return () => {\n      if (window.screen?.orientation) {\n        window.screen.orientation.removeEventListener(\"change\", handleChange);\n      } else {\n        window.removeEventListener(\n          \"orientationchange\",\n          handle_orientationchange\n        );\n      }\n    };\n  }, []);\n\n  return orientation;\n}\n\nconst usePreferredLanguageSubscribe = (cb) => {\n  window.addEventListener(\"languagechange\", cb);\n  return () => window.removeEventListener(\"languagechange\", cb);\n};\n\nconst getPreferredLanguageSnapshot = () => {\n  return navigator.language;\n};\n\nconst getPreferredLanguageServerSnapshot = () => {\n  throw Error(\"usePreferredLanguage is a client-only hook\");\n};\n\nexport function usePreferredLanguage() {\n  return React.useSyncExternalStore(\n    usePreferredLanguageSubscribe,\n    getPreferredLanguageSnapshot,\n    getPreferredLanguageServerSnapshot\n  );\n}\n\nexport function usePrevious(value) {\n  const [current, setCurrent] = React.useState(value);\n  const [previous, setPrevious] = React.useState(null);\n\n  if (value !== current) {\n    setPrevious(current);\n    setCurrent(value);\n  }\n\n  return previous;\n}\n\nexport function useQueue(initialValue = []) {\n  const [queue, setQueue] = React.useState(initialValue);\n\n  const add = React.useCallback((element) => {\n    setQueue((q) => [...q, element]);\n  }, []);\n\n  const remove = React.useCallback(() => {\n    let removedElement;\n\n    setQueue(([first, ...q]) => {\n      removedElement = first;\n      return q;\n    });\n\n    return removedElement;\n  }, []);\n\n  const clear = React.useCallback(() => {\n    setQueue([]);\n  }, []);\n\n  return {\n    add,\n    remove,\n    clear,\n    first: queue[0],\n    last: queue[queue.length - 1],\n    size: queue.length,\n    queue,\n  };\n}\n\nexport function useRenderCount() {\n  const count = React.useRef(0);\n\n  count.current++;\n\n  return count.current;\n}\n\nexport function useRenderInfo(name = \"Unknown\") {\n  const count = React.useRef(0);\n  const lastRender = React.useRef();\n  const now = Date.now();\n\n  count.current++;\n\n  React.useEffect(() => {\n    lastRender.current = Date.now();\n  });\n\n  const sinceLastRender = lastRender.current ? now - lastRender.current : 0;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    const info = {\n      name,\n      renders: count.current,\n      sinceLastRender,\n      timestamp: now,\n    };\n\n    console.log(info);\n\n    return info;\n  }\n}\n\nexport function useScript(src, options = {}) {\n  const [status, setStatus] = React.useState(\"loading\");\n  const optionsRef = React.useRef(options);\n\n  React.useEffect(() => {\n    let script = document.querySelector(`script[src=\"${src}\"]`);\n\n    const domStatus = script?.getAttribute(\"data-status\");\n    if (domStatus) {\n      setStatus(domStatus);\n      return;\n    }\n\n    if (script === null) {\n      script = document.createElement(\"script\");\n      script.src = src;\n      script.async = true;\n      script.setAttribute(\"data-status\", \"loading\");\n      document.body.appendChild(script);\n\n      const handleScriptLoad = () => {\n        script.setAttribute(\"data-status\", \"ready\");\n        setStatus(\"ready\");\n        removeEventListeners();\n      };\n\n      const handleScriptError = () => {\n        script.setAttribute(\"data-status\", \"error\");\n        setStatus(\"error\");\n        removeEventListeners();\n      };\n\n      const removeEventListeners = () => {\n        script.removeEventListener(\"load\", handleScriptLoad);\n        script.removeEventListener(\"error\", handleScriptError);\n      };\n\n      script.addEventListener(\"load\", handleScriptLoad);\n      script.addEventListener(\"error\", handleScriptError);\n\n      const removeOnUnmount = optionsRef.current.removeOnUnmount;\n\n      return () => {\n        if (removeOnUnmount === true) {\n          script.remove();\n          removeEventListeners();\n        }\n      };\n    } else {\n      setStatus(\"unknown\");\n    }\n  }, [src]);\n\n  return status;\n}\n\nconst setSessionStorageItem = (key, value) => {\n  const stringifiedValue = JSON.stringify(value);\n  window.sessionStorage.setItem(key, stringifiedValue);\n  dispatchStorageEvent(key, stringifiedValue);\n};\n\nconst removeSessionStorageItem = (key) => {\n  window.sessionStorage.removeItem(key);\n  dispatchStorageEvent(key, null);\n};\n\nconst getSessionStorageItem = (key) => {\n  return window.sessionStorage.getItem(key);\n};\n\nconst useSessionStorageSubscribe = (callback) => {\n  window.addEventListener(\"storage\", callback);\n  return () => window.removeEventListener(\"storage\", callback);\n};\n\nconst getSessionStorageServerSnapshot = () => {\n  throw Error(\"useSessionStorage is a client-only hook\");\n};\n\nexport function useSessionStorage(key, initialValue) {\n  const getSnapshot = () => getSessionStorageItem(key);\n\n  const store = React.useSyncExternalStore(\n    useSessionStorageSubscribe,\n    getSnapshot,\n    getSessionStorageServerSnapshot\n  );\n\n  const setState = React.useCallback(\n    (v) => {\n      try {\n        const nextState = typeof v === \"function\" ? v(JSON.parse(store)) : v;\n\n        if (nextState === undefined || nextState === null) {\n          removeSessionStorageItem(key);\n        } else {\n          setSessionStorageItem(key, nextState);\n        }\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n    [key, store]\n  );\n\n  React.useEffect(() => {\n    if (\n      getSessionStorageItem(key) === null &&\n      typeof initialValue !== \"undefined\"\n    ) {\n      setSessionStorageItem(key, initialValue);\n    }\n  }, [key, initialValue]);\n\n  return [store ? JSON.parse(store) : initialValue, setState];\n}\n\nexport function useSet(values) {\n  const setRef = React.useRef(new Set(values));\n  const [, reRender] = React.useReducer((x) => x + 1, 0);\n\n  setRef.current.add = (...args) => {\n    const res = Set.prototype.add.apply(setRef.current, args);\n    reRender();\n\n    return res;\n  };\n\n  setRef.current.clear = (...args) => {\n    Set.prototype.clear.apply(setRef.current, args);\n    reRender();\n  };\n\n  setRef.current.delete = (...args) => {\n    const res = Set.prototype.delete.apply(setRef.current, args);\n    reRender();\n\n    return res;\n  };\n\n  return setRef.current;\n}\n\nexport function useThrottle(value, interval = 500) {\n  const [throttledValue, setThrottledValue] = React.useState(value);\n  const lastUpdated = React.useRef(null);\n\n  React.useEffect(() => {\n    const now = Date.now();\n\n    if (lastUpdated.current && now >= lastUpdated.current + interval) {\n      lastUpdated.current = now;\n      setThrottledValue(value);\n    } else {\n      const id = window.setTimeout(() => {\n        lastUpdated.current = now;\n        setThrottledValue(value);\n      }, interval);\n\n      return () => window.clearTimeout(id);\n    }\n  }, [value, interval]);\n\n  return throttledValue;\n}\n\nexport function useToggle(initialValue) {\n  const [on, setOn] = React.useState(() => {\n    if (typeof initialValue === \"boolean\") {\n      return initialValue;\n    }\n\n    return Boolean(initialValue);\n  });\n\n  const handleToggle = React.useCallback((value) => {\n    if (typeof value === \"boolean\") {\n      return setOn(value);\n    }\n\n    return setOn((v) => !v);\n  }, []);\n\n  return [on, handleToggle];\n}\n\nconst useVisibilityChangeSubscribe = (callback) => {\n  document.addEventListener(\"visibilitychange\", callback);\n\n  return () => {\n    document.removeEventListener(\"visibilitychange\", callback);\n  };\n};\n\nconst getVisibilityChangeSnapshot = () => {\n  return document.visibilityState;\n};\n\nconst getVisibilityChangeServerSnapshot = () => {\n  throw Error(\"useVisibilityChange is a client-only hook\");\n};\n\nexport function useVisibilityChange() {\n  const visibilityState = React.useSyncExternalStore(\n    useVisibilityChangeSubscribe,\n    getVisibilityChangeSnapshot,\n    getVisibilityChangeServerSnapshot\n  );\n\n  return visibilityState === \"visible\";\n}\n\nexport function useWindowScroll() {\n  const [state, setState] = React.useState({\n    x: null,\n    y: null,\n  });\n\n  const scrollTo = React.useCallback((...args) => {\n    if (typeof args[0] === \"object\") {\n      window.scrollTo(args[0]);\n    } else if (typeof args[0] === \"number\" && typeof args[1] === \"number\") {\n      window.scrollTo(args[0], args[1]);\n    } else {\n      throw new Error(\n        `Invalid arguments passed to scrollTo. See here for more info. https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo`\n      );\n    }\n  }, []);\n\n  React.useLayoutEffect(() => {\n    const handleScroll = () => {\n      setState({ x: window.scrollX, y: window.scrollY });\n    };\n\n    handleScroll();\n    window.addEventListener(\"scroll\", handleScroll);\n\n    return () => {\n      window.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, []);\n\n  return [state, scrollTo];\n}\n\nexport function useWindowSize() {\n  const [size, setSize] = React.useState({\n    width: null,\n    height: null,\n  });\n\n  React.useLayoutEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, []);\n\n  return size;\n}\n","import React from 'react';\nimport ContactBook from 'components/ContactBook';\n\nexport default function ContactsPage() {\n  return <ContactBook />;\n}\n"],"names":["_ref","type","name","label","title","pattern","required","handleChange","autoComplete","_jsxs","className","styles","children","_jsx","onChange","htmlFor","handleSubmit","onSubmit","selectContacts","state","contactsSlice","contacts","items","selectFilter","filter","selectLoading","isLoading","selectError","error","_useState","useState","number","_useState2","_slicedToArray","newContact","setNewContact","_useState3","_useState4","disabled","setDisabled","_useState5","_useState6","searchTherm","setSearchTherm","debouncedSearchTerm","value","delay","_React$useState7","React","_React$useState8","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useDebounce","initialContacts","useSelector","filterSliceStore","isError","dispatch","useDispatch","e","_e$target","target","length","_objectSpread","_defineProperty","find","contact","console","log","toLowerCase","alert","concat","useEffect","fetchContacts","filterContact","getContactsByName","includes","undefined","Form","ev","preventDefault","form","addContact","reset","Input","Button","style","margin","fontSize","Loading","Alert","message","map","variant","handleClick","id","deleteContact","ContactsPage","ContactBook"],"sourceRoot":""}